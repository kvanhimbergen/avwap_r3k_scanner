import os
import time
import threading
import requests
from typing import Optional

# Levels (ordered)
_LEVELS = {"INFO": 10, "WARNING": 20, "ERROR": 30, "TRADE": 15}

# Simple in-memory throttling: key -> last_ts
_LAST_TS: dict[str, float] = {}


def _enabled() -> bool:
    if os.getenv("SLACK_ALERTS_ENABLED", "1").strip() not in ("1", "true", "TRUE", "yes", "YES"):
        return False
    return bool(os.getenv("SLACK_WEBHOOK_URL", "").strip())


def _min_level_ok(level: str) -> bool:
    min_level = os.getenv("SLACK_ALERTS_MIN_LEVEL", "INFO").strip().upper()
    return _LEVELS.get(level, 10) >= _LEVELS.get(min_level, 10)


def should_throttle(key: str, cooldown_seconds: int) -> bool:
    """Return True if a message for this key should be suppressed."""
    now = time.time()
    last = _LAST_TS.get(key, 0.0)
    if cooldown_seconds > 0 and (now - last) < cooldown_seconds:
        return True
    _LAST_TS[key] = now
    return False


def _post(payload: dict) -> None:
    url = os.getenv("SLACK_WEBHOOK_URL", "").strip()
    if not url:
        return
    # Hard timeouts so we never block systemd services
    requests.post(url, json=payload, timeout=(2, 3))


def slack_alert(
    level: str,
    title: str,
    message: str,
    component: str = "BOT",
    *,
    throttle_key: Optional[str] = None,
    throttle_seconds: int = 0,
) -> None:
    """
    Non-blocking Slack alert via Incoming Webhook.

    - No-ops if SLACK_WEBHOOK_URL missing or SLACK_ALERTS_ENABLED=0
    - Uses a short background thread and tight HTTP timeouts
    - Optional throttle to avoid alert storms
    """
    level = (level or "INFO").strip().upper()
    if level not in _LEVELS:
        level = "INFO"

    if not _enabled() or not _min_level_ok(level):
        return

    if throttle_key and should_throttle(throttle_key, throttle_seconds):
        return

    prefix = f"[AVWAP][{component}][{level}]"
    text = f"{prefix} {title}\n{message}".strip()

    payload: dict = {"text": text}

    # Optional overrides (webhook must allow)
    chan = os.getenv("SLACK_ALERTS_CHANNEL", "").strip()
    if chan:
        payload["channel"] = chan
    username = os.getenv("SLACK_ALERTS_USERNAME", "").strip()
    if username:
        payload["username"] = username

    def _worker() -> None:
        try:
            _post(payload)
        except Exception:
            # Fail-closed: never raise into the trading process.
            pass

    threading.Thread(target=_worker, daemon=True).start()
